from bdecode import bdecode

# old
import hashlib
import ipaddress
import struct
import socket
import hexdump
import binascii
import requests
import os
import binascii
import json
import threading
import time
import struct
import math
import hashlib
from progress.bar import Bar

# taken from https://wiki.theory.org/Decoding_bencoded_data_with_python
# fixed to work with python3 bytearrays
# could precompute ords but this is more readable



class Torrent:
	def __init__(self,torrent_file):
		self.torrent_file = torrent_file
		self.torrent = None
		self.peers = None
		self.piece_hashes = []
		# fingerprint for others, not trying to be subtle
		self.peer_id = b"Peer2Peers" + os.urandom(10)
		self.__load_torrent_file(torrent_file)
		self.info_hash = self.torrent['info_hash']
		self.length = self.torrent['info']['length']
		self.piece_length = self.torrent['info']['piece length']
		self.__load_piece_hashes(self.torrent['info']['pieces'])
		self.__get_peers()

	def __str__(self):
		# TODO workng with single file torrent only for now
		"""
		{
			"announce": "https://torrent.ubuntu.com/announce", 
			"comment": "Xubuntu CD cdimage.ubuntu.com", 
			"created by": "mktorrent 1.1", 
			"creation date": 1596727330, 
			"info": {
					"length": 1699577856, 
					"name": "xubuntu-20.04.1-desktop-amd64.iso", 
					"piece length": 262144, 
					"pieces": "<--SNIP-->"
				}
		}
		"""
		s  = f"Torrent file: {self.torrent_file}\n"
		s += f"announce: {self.torrent['announce']}\n"
		s += f"comment: {self.torrent['comment']}\n"
		s += f"created by: {self.torrent['created by']}\n"
		s += f"creation date: {self.torrent['creation date']}\n"
		s += f"name: {self.torrent['info']['name']}\n"
		s += f"length: {self.torrent['info']['length']}\n"
		s += f"number of pieces: {len(self.piece_hashes)}\n"
		s += f"piece length: {self.torrent['info']['piece length']}\n"
		s += f"info hash: {binascii.hexlify(self.torrent['info_hash']).decode('utf-8')}"
		return s

	def __get_peers(self):
		# request list of peers from tracker
		info_hash = self.torrent['info_hash']

		"""
		info_hash: 
			urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file. 
			Note that the value will be a bencoded dictionary, given the definition of the 
			info key above.
		peer_id: 
			urlencoded 20-byte string used as a unique ID for the client, generated by the client 
			at startup. This is allowed to be any value, and may be binary data. There are currently 
			no guidelines for generating this peer ID. However, one may rightly presume that it must 
			at least be unique for your local machine, thus should probably incorporate things like 
			process ID and perhaps a timestamp recorded at startup. See peer_id below for common 
			client encodings of this field.
		port: 
			The port number that the client is listening on. Ports reserved for BitTorrent are 
			typically 6881-6889. Clients may choose to give up if it cannot establish a port within this range.
		uploaded: 
			The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII. 
			While not explicitly stated in the official specification, the concensus is that this should be 
			the total number of bytes uploaded.
		downloaded: 
			The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII. 
			While not explicitly stated in the official specification, the consensus is that this should be the total 
			number of bytes downloaded.
		left: 
			The number of bytes this client still has to download in base ten ASCII. Clarification: The number of bytes 
			needed to download to be 100% complete and get all the included files in the torrent.
		compact: 
			Setting this to 1 indicates that the client accepts a compact response. The peers list is replaced by a 
			peers string with 6 bytes per peer. The first four bytes are the host (in network byte order), the last 
			two bytes are the port (again in network byte order). It should be noted that some trackers only support 
			compact responses (for saving bandwidth) and either refuse requests without "compact=1" or simply send a 
			compact response unless the request contains "compact=0" (in which case they will refuse the request.)
		no_peer_id: 
			Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
		event: 
			If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified). 
			If not specified, then this request is one performed at regular intervals.
		started: 
			The first request to the tracker must include the event key with this value.
		stopped: 
			Must be sent to the tracker if the client is shutting down gracefully.
		completed: 
			Must be sent to the tracker when the download completes. However, must not be sent if the download was already 100% complete when the client started. Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
		ip: 
			Optional. The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 
			address. Notes: In general this parameter is not necessary as the address of the client can be determined 
			from the IP address from which the HTTP request came. The parameter is only needed in the case where the 
			IP address that the request came in on is not the IP address of the client. This happens if the client 
			is communicating to the tracker through a proxy (or a transparent web proxy/cache.) It also is necessary 
			when both the client and the tracker are on the same local side of a NAT gateway. The reason for this is 
			that otherwise the tracker would give out the internal (RFC1918) address of the client, which is not routable. 
			Therefore the client must explicitly state its (external, routable) IP address to be given out to external 
			peers. Various trackers treat this parameter differently. Some only honor it only if the IP address that 
			the request came in on is in RFC1918 space. Others honor it unconditionally, while others ignore it 
			completely. In case of IPv6 address (e.g.: 2001:db8:1:2::100) it indicates only that client can communicate 
			via IPv6.
		numwant: 
			Optional. Number of peers that the client would like to receive from the tracker. This value is permitted to 
			be zero. If omitted, typically defaults to 50 peers.
		key: 
			Optional. An additional identification that is not shared with any other peers. It is intended to allow a client to prove their identity should their IP address change.
			trackerid: Optional. If a previous announce contained a tracker id, it should be set here.
		"""

		p = {
			"info_hash": self.info_hash,
			"peer_id": self.peer_id,
			"port": 6881, # 6881-6889 are common ports for torrenting
			"uploaded": "0",
			"downloaded": "0",
			"left": self.torrent['info']['length'],
			"compact": 1,
			"no_peer_id": 0,
			"event": "started", # stopped, completed
			# "ip": -- optional
			"numwant": 99999 # we want all of the peers
			# "key": -- optional
			# "trackerid": -- optional
		}
		r = requests.get(self.torrent['announce'], params = p)
		if r.status_code != 200:
			raise Exception(f"Bad response from {self.torrent['announce']}")
		tracker_response = bdecode(r.text)
		self.peers = self.__parse_peers(tracker_response['peers'])

	def __load_piece_hashes(self, piece_hashes_concat):
		for i in range(0, int(len(piece_hashes_concat)), 20):
			# these are strings from the bdecoding, convert
			piece_hash = piece_hashes_concat[i:i+20]
			piece_hash_bytes = bytearray()
			piece_hash_bytes.extend(map(ord, piece_hash))
			self.piece_hashes.append(bytes(piece_hash_bytes))

	def __load_torrent_file(self, torrent_file):
		with open(torrent_file, 'rb') as f:
			data = f.read()

		torrent = self.__parse_torrent_file(data)

	def __parse_torrent_file(self, data):
		chunks = bytearray(data)
		chunks.reverse()
		root = self.__torrent_dechunk(chunks)
		self.torrent = root


	def __torrent_dechunk(self, chunks):
		item = chunks.pop()
		if item == ord('d'): 
			item = chunks.pop()
			h = {}
			while item != ord('e'):
				chunks.append(item)
				key = self.__torrent_dechunk(chunks)
				# lookahead on info to hash
				if key == 'info':
					# calculate hash of the bencoded info value
					# necessary for other parts of the protocol
					old_chunks = list(chunks)
					old_chunks.reverse()
					end = len(chunks) - 1
					h[key] = self.__torrent_dechunk(chunks)
					start = len(chunks) - 1 
					m = hashlib.sha1()
					m.update(bytes(old_chunks[start:end]))
					info_hash = m.digest()
					h['info_hash'] = info_hash # binascii.hexlify(h)
				else:
					h[key] = self.__torrent_dechunk(chunks)
				item = chunks.pop()
			return h
		elif item == ord('l'):
			item = chunks.pop()
			l = []
			while item != ord('e'):
				chunks.append(item)
				l.append(self.__torrent_dechunk(chunks))
				item = chunks.pop()
			return list
		elif item == ord('i'):
			item = chunks.pop()
			num = ''
			while item != ord('e'):
				num  += chr(item)
				item = chunks.pop()
			return int(num)
		elif item < 0x3A and item >= 0x30: # checking if this is a decimal
			num = ''
			while item < 0x3A and item >= 0x30 :
				num += chr(item)
				item = chunks.pop()
			line = ''
			for i in range(int(num)):
				line += chr(chunks.pop())
			return line
		else:
			raise Exception("Invalid input!")


	def __parse_peers(self, peers):
		# untested, attempt to discern between the two models
		if type(peers) == dict:
			"""
			peers: (dictionary model) The value is a list of dictionaries, each with the following keys:
				peer id: peer's self-selected ID, as described above for the tracker request (string)
				ip: peer's IP address either IPv6 (hexed) or IPv4 (dotted quad) or DNS name (string)
				port: peer's port number (integer)
			"""
			# Nothing needs to happen here.
			# recursive bdecoding will handle it
			return peers
		else:
			"""
			peers: (binary model) Instead of using the dictionary model described above, 
			the peers value may be a string consisting of multiples of 6 bytes. 
			First 4 bytes are the IP address and last 2 bytes are the port number. 
			All in network (big endian) notation.
			"""
			peers_list = []
			for i in range(0, int(len(peers)), 6):
				b = bytearray()
				b.extend(map(ord,peers[i:i+6]))
				ip, port = struct.unpack('!IH',b)
				ip = str(ipaddress.ip_address(ip))
				peers_list.append({'ip':ip,'port':port})
			return peers_list

		raise Exception("Couldn't decode peers")

	